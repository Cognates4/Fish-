
import random
import time
import json
from os import system
from datetime import datetime, timedelta

def clear():
    system('clear')

# Game configuration
GIANT_NET_COOLDOWN = 300  # 5 minutes in seconds
LEVEL_EXP_BASE = 100  # Base experience needed for first level
LEVEL_EXP_SCALE = 1.5  # Scaling factor for each level

# Seasons and their effects
seasons = {
    "Spring": {"rarity_boost": 1.1, "description": "Fish are more active as waters warm."},
    "Summer": {"rarity_boost": 1.0, "description": "Standard fishing conditions ."},
    "Fall": {"rarity_boost": 1.2, "description": "Migratory fish are more common."},
    "Winter": {"rarity_boost": 0.8, "description": "Fishing is more challenging in cold waters."}
}

# Time-based fishing conditions
time_conditions = {
    "Dawn": {"hours": [5, 6, 7], "rarity_boost": 1.3, "description": "Many fish are active at dawn."},
    "Day": {"hours": [8, 9, 10, 11, 12, 13, 14, 15], "rarity_boost": 1.0, "description": "Standard fishing conditions."},
    "Dusk": {"hours": [16, 17, 18], "rarity_boost": 1.4, "description": "Prime fishing time as the sun sets."},
    "Night": {"hours": [19, 20, 21, 22, 23, 0, 1, 2, 3, 4], "rarity_boost": 0.9, "description": "Some special fish only appear at night."}
}

# Special events with their boosts
events = {
    "Fishing Festival": {"chance": 0.10, "duration": 48, "rarity_boost": 1.5, "description": "Annual celebration increases all fish activity!"},
    "Lunar Phase": {"chance": 0.15, "duration": 24, "rarity_boost": 1.3, "description": "The full moon brings rare fish closer to shore."},
    "Migration": {"chance": 0.08, "duration": 72, "rarity_boost": 1.4, "description": "Schools of migratory fish are passing through!"},
    "Storm Front": {"chance": 0.12, "duration": 24, "rarity_boost": 1.2, "description": "The changing weather has fish feeding aggressively."},
    "Clear Waters": {"chance": 0.10, "duration": 36, "rarity_boost": 1.25, "description": "Exceptionally clear water makes fish easier to spot."}
}

# Fishing boosts and items
fishing_boosts = {
    "Premium Bait": {"price": 500, "effect": "rarity_boost", "value": 1.2, "duration": 10, "description": "Attracts rarer fish for 10 catches."},
    "Lucky Charm": {"price": 2000, "effect": "luck_boost", "value": 1.3, "duration": 20, "description": "Increases chance of multiple catches for 20 catches."},
    "Fish Finder": {"price": 5000, "effect": "find_boost", "value": 1.5, "duration": 15, "description": "Helps locate rarer fish for 15 catches."},
    "Time Warp": {"price": 1000, "effect": "time_boost", "value": 0.5, "duration": 30, "description": "Reduces Giant Net cooldown by 50% for 30 minutes."},
    "XP Booster": {"price": 3000, "effect": "xp_boost", "value": 1.5, "duration": 25, "description": "Increases XP gain by 50% for 25 catches."},
    "Golden Hook": {"price": 10000, "effect": "value_boost", "value": 1.4, "duration": 20, "description": "Increases sell value of fish by 40% for 20 catches."},
    "Weather Control": {"price": 25000, "effect": "weather_control", "value": 1.0, "duration": 5, "description": "Allows you to select the weather for 5 fishing trips."},
    "Midas Touch": {"price": 100000, "effect": "midas_touch", "value": 2.0, "duration": 3, "description": "Doubles the value of the next 3 catches."}
}

fishing_rods = {
    "Basic Rod": {"price": 0, "rare_bonus": 1.0},
    "Bamboo Rod": {"price": 1000, "rare_bonus": 1.3},  # New affordable early rod
    "Amateur Rod": {"price": 3000, "rare_bonus": 1.6},  # More balanced pricing
    "Fiberglass Rod": {"price": 6000, "rare_bonus": 1.8},  # New mid-level rod
    "Pro Rod": {"price": 12000, "rare_bonus": 2.1},     # More balanced mid-game rod
    "Carbon Fiber Rod": {"price": 25000, "rare_bonus": 2.5},  # New higher-tier rod
    "Expert Rod": {"price": 60000, "rare_bonus": 3.2},  # Better bonus for the price
    "Telescopic Rod": {"price": 100000, "rare_bonus": 3.8},  # New specialized rod
    "Master Rod": {"price": 250000, "rare_bonus": 4.5}, # More affordable late-game rod
    "Legendary Rod": {"price": 800000, "rare_bonus": 6.5}, # Better bonus for the price
    "Divine Rod": {"price": 3000000, "rare_bonus": 10.0}    # Better value end-game
}

# Boats with locations they unlock
boats = {
    "Wooden Rowboat": {"price": 3000, "locations": ["Pond", "Lake"]},
    "Canoe": {"price": 8000, "locations": ["Pond", "Lake", "Creek"]},  # New boat and location
    "Small Motorboat": {"price": 30000, "locations": ["Pond", "Lake", "Creek", "River"]},
    "Bass Boat": {"price": 80000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir"]},  # New boat and location
    "Fishing Trawler": {"price": 200000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir", "Bay"]},
    "Catamaran": {"price": 500000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir", "Bay", "Reef"]},  # New boat and location
    "Yacht": {"price": 1200000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir", "Bay", "Reef", "Coast"]},
    "Deep Sea Vessel": {"price": 3000000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir", "Bay", "Reef", "Coast", "Deep Sea"]},
    "Research Ship": {"price": 10000000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir", "Bay", "Reef", "Coast", "Deep Sea", "Arctic"]},
    "Submarine": {"price": 50000000, "locations": ["Pond", "Lake", "Creek", "River", "Reservoir", "Bay", "Reef", "Coast", "Deep Sea", "Arctic", "Abyss"]}  # New ultimate boat and location
}

# Different locations with their fish
locations = {
    "Pond": {
        "description": "A small, peaceful pond with common freshwater fish.",
        "unlocked": True,  # Starter location
        "fish": {
            "Minnow": {"rarity": 30, "catch_rate": 40, "value": 50, "price": 50, "exp": 2},
            "Sunfish": {"rarity": 25, "catch_rate": 38, "value": 100, "price": 100, "exp": 3},
            "Perch": {"rarity": 22, "catch_rate": 36, "value": 150, "price": 150, "exp": 4},
            "Salmon": {"rarity": 20, "catch_rate": 32, "value": 200, "price": 200, "exp": 5},
            "Carp": {"rarity": 18, "catch_rate": 30, "value": 300, "price": 300, "exp": 6},
            "Bass": {"rarity": 15, "catch_rate": 25, "value": 500, "price": 500, "exp": 10},
            "Haddock": {"rarity": 12, "catch_rate": 20, "value": 750, "price": 750, "exp": 15},
            "Goldfish": {"rarity": 8, "catch_rate": 15, "value": 1200, "price": 1200, "exp": 20},
            "Koi": {"rarity": 5, "catch_rate": 10, "value": 2000, "price": 2000, "exp": 30},
            "Albino Carp": {"rarity": 3, "catch_rate": 5, "value": 3500, "price": 3500, "exp": 50}
        }
    },
    "Creek": {
        "description": "A narrow, flowing creek with unique small fish.",
        "unlocked": False,
        "fish": {
            "Creek Chub": {"rarity": 25, "catch_rate": 35, "value": 200, "price": 200, "exp": 5},
            "Dace": {"rarity": 22, "catch_rate": 30, "value": 350, "price": 350, "exp": 8},
            "Shiner": {"rarity": 18, "catch_rate": 28, "value": 500, "price": 500, "exp": 12},
            "Brook Trout": {"rarity": 15, "catch_rate": 25, "value": 800, "price": 800, "exp": 18},
            "Darter": {"rarity": 12, "catch_rate": 20, "value": 1200, "price": 1200, "exp": 25},
            "Sculpin": {"rarity": 10, "catch_rate": 15, "value": 1800, "price": 1800, "exp": 30},
            "Longnose Gar": {"rarity": 7, "catch_rate": 12, "value": 2500, "price": 2500, "exp": 40},
            "Mountain Whitefish": {"rarity": 5, "catch_rate": 8, "value": 3800, "price": 3800, "exp": 55},
            "Golden Darter": {"rarity": 3, "catch_rate": 5, "value": 5000, "price": 5000, "exp": 75},
            "Spotted Killifish": {"rarity": 2, "catch_rate": 3, "value": 8000, "price": 8000, "exp": 100}
        }
    },
    "Lake": {
        "description": "A larger body of water with a variety of fish.",
        "unlocked": False,
        "fish": {
            "Bluegill": {"rarity": 22, "catch_rate": 30, "value": 400, "price": 400, "exp": 8},
            "Crappie": {"rarity": 18, "catch_rate": 25, "value": 700, "price": 700, "exp": 12},
            "Yellow Perch": {"rarity": 15, "catch_rate": 22, "value": 1000, "price": 1000, "exp": 18},
            "Walleye": {"rarity": 12, "catch_rate": 20, "value": 1500, "price": 1500, "exp": 25},
            "Smallmouth Bass": {"rarity": 10, "catch_rate": 18, "value": 2500, "price": 2500, "exp": 35},
            "Northern Pike": {"rarity": 8, "catch_rate": 15, "value": 4000, "price": 4000, "exp": 45},
            "Largemouth Bass": {"rarity": 6, "catch_rate": 10, "value": 6000, "price": 6000, "exp": 60},
            "Lake Trout": {"rarity": 5, "catch_rate": 8, "value": 8500, "price": 8500, "exp": 75},
            "Muskie": {"rarity": 3, "catch_rate": 5, "value": 12000, "price": 12000, "exp": 90},
            "Lake Sturgeon": {"rarity": 2, "catch_rate": 3, "value": 18000, "price": 18000, "exp": 120}
        }
    },
    "Reservoir": {
        "description": "A man-made lake with deep waters and special fish.",
        "unlocked": False,
        "fish": {
            "White Bass": {"rarity": 20, "catch_rate": 28, "value": 600, "price": 600, "exp": 12},
            "White Crappie": {"rarity": 18, "catch_rate": 25, "value": 900, "price": 900, "exp": 18},
            "Spotted Bass": {"rarity": 15, "catch_rate": 22, "value": 1400, "price": 1400, "exp": 25},
            "Striped Bass": {"rarity": 12, "catch_rate": 18, "value": 2200, "price": 2200, "exp": 35},
            "Sauger": {"rarity": 10, "catch_rate": 15, "value": 3500, "price": 3500, "exp": 45},
            "Paddlefish": {"rarity": 8, "catch_rate": 12, "value": 5500, "price": 5500, "exp": 60},
            "Freshwater Drum": {"rarity": 6, "catch_rate": 10, "value": 8000, "price": 8000, "exp": 70},
            "Blue Catfish": {"rarity": 4, "catch_rate": 7, "value": 12000, "price": 12000, "exp": 85},
            "Flathead Catfish": {"rarity": 3, "catch_rate": 5, "value": 18000, "price": 18000, "exp": 100},
            "Alligator Gar": {"rarity": 2, "catch_rate": 3, "value": 25000, "price": 25000, "exp": 130}
        }
    },
    "River": {
        "description": "A flowing river with unique fish species.",
        "unlocked": False,
        "fish": {
            "Shad": {"rarity": 20, "catch_rate": 28, "value": 800, "price": 800, "exp": 15},
            "Rainbow Trout": {"rarity": 18, "catch_rate": 25, "value": 1200, "price": 1200, "exp": 20},
            "Brown Trout": {"rarity": 15, "catch_rate": 22, "value": 1800, "price": 1800, "exp": 30},
            "Cutthroat Trout": {"rarity": 12, "catch_rate": 20, "value": 3000, "price": 3000, "exp": 40},
            "Channel Catfish": {"rarity": 10, "catch_rate": 16, "value": 4500, "price": 4500, "exp": 50},
            "Steelhead": {"rarity": 8, "catch_rate": 12, "value": 7000, "price": 7000, "exp": 65},
            "River Perch": {"rarity": 6, "catch_rate": 10, "value": 10000, "price": 10000, "exp": 80},
            "Chinook Salmon": {"rarity": 4, "catch_rate": 7, "value": 15000, "price": 15000, "exp": 100},
            "Bull Trout": {"rarity": 3, "catch_rate": 4, "value": 22000, "price": 22000, "exp": 120},
            "Giant Catfish": {"rarity": 2, "catch_rate": 2, "value": 30000, "price": 30000, "exp": 150}
        }
    },
    "Bay": {
        "description": "A sheltered coastal area with brackish water species.",
        "unlocked": False,
        "fish": {
            "Bay Anchovy": {"rarity": 22, "catch_rate": 30, "value": 1000, "price": 1000, "exp": 20},
            "Spot": {"rarity": 18, "catch_rate": 25, "value": 1800, "price": 1800, "exp": 30},
            "Croaker": {"rarity": 15, "catch_rate": 22, "value": 3000, "price": 3000, "exp": 40},
            "Striped Mullet": {"rarity": 12, "catch_rate": 18, "value": 5000, "price": 5000, "exp": 55},
            "Weakfish": {"rarity": 10, "catch_rate": 15, "value": 8000, "price": 8000, "exp": 70},
            "Sheepshead": {"rarity": 8, "catch_rate": 12, "value": 12000, "price": 12000, "exp": 85},
            "Red Drum": {"rarity": 6, "catch_rate": 9, "value": 18000, "price": 18000, "exp": 100},
            "Flounder": {"rarity": 4, "catch_rate": 6, "value": 25000, "price": 25000, "exp": 120},
            "Snook": {"rarity": 3, "catch_rate": 4, "value": 35000, "price": 35000, "exp": 150},
            "Giant Crab": {"rarity": 2, "catch_rate": 2, "value": 50000, "price": 50000, "exp": 200}
        }
    },
    "Reef": {
        "description": "A colorful coral reef teeming with exotic fish.",
        "unlocked": False,
        "fish": {
            "Damselfish": {"rarity": 20, "catch_rate": 28, "value": 1500, "price": 1500, "exp": 25},
            "Butterflyfish": {"rarity": 18, "catch_rate": 25, "value": 2500, "price": 2500, "exp": 35},
            "Wrasse": {"rarity": 15, "catch_rate": 22, "value": 4000, "price": 4000, "exp": 50},
            "Parrotfish": {"rarity": 12, "catch_rate": 18, "value": 7000, "price": 7000, "exp": 65},
            "Angelfish": {"rarity": 10, "catch_rate": 15, "value": 12000, "price": 12000, "exp": 80},
            "Lionfish": {"rarity": 8, "catch_rate": 12, "value": 18000, "price": 18000, "exp": 100},
            "Triggerfish": {"rarity": 6, "catch_rate": 9, "value": 25000, "price": 25000, "exp": 120},
            "Moray Eel": {"rarity": 4, "catch_rate": 6, "value": 35000, "price": 35000, "exp": 150},
            "Reef Shark": {"rarity": 3, "catch_rate": 4, "value": 50000, "price": 50000, "exp": 180},
            "Blue-Ringed Octopus": {"rarity": 2, "catch_rate": 2, "value": 70000, "price": 70000, "exp": 230}
        }
    },
    "Coast": {
        "description": "The open coastline with diverse saltwater fish.",
        "unlocked": False,
        "fish": {
            "Mackerel": {"rarity": 20, "catch_rate": 28, "value": 2000, "price": 2000, "exp": 30},
            "Jack": {"rarity": 18, "catch_rate": 25, "value": 3500, "price": 3500, "exp": 45},
            "Bluefish": {"rarity": 15, "catch_rate": 22, "value": 6000, "price": 6000, "exp": 60},
            "Sea Bass": {"rarity": 12, "catch_rate": 18, "value": 10000, "price": 10000, "exp": 75},
            "Snapper": {"rarity": 10, "catch_rate": 15, "value": 15000, "price": 15000, "exp": 90},
            "Grouper": {"rarity": 8, "catch_rate": 12, "value": 22000, "price": 22000, "exp": 110},
            "Mahi Mahi": {"rarity": 6, "catch_rate": 9, "value": 30000, "price": 30000, "exp": 130},
            "Yellowfin Tuna": {"rarity": 4, "catch_rate": 6, "value": 45000, "price": 45000, "exp": 160},
            "Sailfish": {"rarity": 3, "catch_rate": 4, "value": 60000, "price": 60000, "exp": 200},
            "Marlin": {"rarity": 2, "catch_rate": 2, "value": 90000, "price": 90000, "exp": 250}
        }
    },
    "Deep Sea": {
        "description": "The mysterious depths of the ocean with rare fish.",
        "unlocked": False,
        "fish": {
            "Hake": {"rarity": 18, "catch_rate": 25, "value": 5000, "price": 5000, "exp": 50},
            "Monkfish": {"rarity": 15, "catch_rate": 22, "value": 8000, "price": 8000, "exp": 70},
            "Cod": {"rarity": 12, "catch_rate": 18, "value": 15000, "price": 15000, "exp": 90},
            "Haddock": {"rarity": 10, "catch_rate": 15, "value": 25000, "price": 25000, "exp": 110},
            "Conger Eel": {"rarity": 8, "catch_rate": 12, "value": 40000, "price": 40000, "exp": 140},
            "Swordfish": {"rarity": 6, "catch_rate": 9, "value": 60000, "price": 60000, "exp": 180},
            "Bluefin Tuna": {"rarity": 4, "catch_rate": 6, "value": 90000, "price": 90000, "exp": 220},
            "Giant Squid": {"rarity": 3, "catch_rate": 4, "value": 130000, "price": 130000, "exp": 280},
            "Oarfish": {"rarity": 2, "catch_rate": 2, "value": 180000, "price": 180000, "exp": 350},
            "Sunfish": {"rarity": 1, "catch_rate": 1, "value": 250000, "price": 250000, "exp": 450}
        }
    },
    "Arctic": {
        "description": "The frigid waters of the Arctic with extremely rare fish.",
        "unlocked": False,
        "fish": {
            "Arctic Char": {"rarity": 15, "catch_rate": 22, "value": 10000, "price": 10000, "exp": 80},
            "Arctic Cod": {"rarity": 12, "catch_rate": 18, "value": 18000, "price": 18000, "exp": 100},
            "Arctic Flounder": {"rarity": 10, "catch_rate": 15, "value": 30000, "price": 30000, "exp": 130},
            "Greenland Halibut": {"rarity": 8, "catch_rate": 12, "value": 50000, "price": 50000, "exp": 160},
            "Polar Cod": {"rarity": 6, "catch_rate": 9, "value": 80000, "price": 80000, "exp": 200},
            "Beluga": {"rarity": 4, "catch_rate": 6, "value": 120000, "price": 120000, "exp": 250},
            "Narwhal": {"rarity": 3, "catch_rate": 4, "value": 180000, "price": 180000, "exp": 300},
            "Greenland Shark": {"rarity": 2, "catch_rate": 2, "value": 250000, "price": 250000, "exp": 400},
            "Giant Isopod": {"rarity": 1, "catch_rate": 1, "value": 350000, "price": 350000, "exp": 500},
            "Frost Whale": {"rarity": 0.5, "catch_rate": 0.5, "value": 500000, "price": 500000, "exp": 700}
        }
    },
    "Abyss": {
        "description": "The darkest depths where legendary creatures lurk.",
        "unlocked": False,
        "fish": {
            "Lanternfish": {"rarity": 12, "catch_rate": 18, "value": 20000, "price": 20000, "exp": 100},
            "Viperfish": {"rarity": 10, "catch_rate": 15, "value": 35000, "price": 35000, "exp": 150},
            "Gulper Eel": {"rarity": 8, "catch_rate": 12, "value": 60000, "price": 60000, "exp": 200},
            "Fangtooth": {"rarity": 6, "catch_rate": 9, "value": 100000, "price": 100000, "exp": 250},
            "Black Dragonfish": {"rarity": 5, "catch_rate": 7, "value": 150000, "price": 150000, "exp": 300},
            "Anglerfish": {"rarity": 4, "catch_rate": 5, "value": 220000, "price": 220000, "exp": 350},
            "Giant Isopod": {"rarity": 3, "catch_rate": 3, "value": 300000, "price": 300000, "exp": 450},
            "Blobfish": {"rarity": 2, "catch_rate": 2, "value": 400000, "price": 400000, "exp": 550},
            "Frilled Shark": {"rarity": 1, "catch_rate": 1, "value": 600000, "price": 600000, "exp": 700},
            "Colossal Squid": {"rarity": 0.5, "catch_rate": 0.5, "value": 1000000, "price": 1000000, "exp": 1000}
        }
    }
}

# Original fish from the pond - used as fallback and for the Giant Net
fish_types = {}
for location_name, location_data in locations.items():
    fish_types.update(location_data["fish"])

# Separate fish into rarity tiers for Giant Net
common_fish = [name for name, data in fish_types.items() if data["rarity"] > 10]
uncommon_fish = [name for name, data in fish_types.items() if 5 < data["rarity"] <= 10]
rare_fish = [name for name, data in fish_types.items() if 2 < data["rarity"] <= 5]
very_rare_fish = [name for name, data in fish_types.items() if data["rarity"] <= 2]

miscellaneous_items = {
    "Seaweed": {"value": 50, "rarity": 40},
    "Driftwood": {"value": 80, "rarity": 35},
    "Boots": {"value": 100, "rarity": 30},
    "Tin Can": {"value": 120, "rarity": 28},
    "Plastic Bottle": {"value": 150, "rarity": 25},
    "Message Bottle": {"value": 500, "rarity": 20},
    "Fishing Net": {"value": 800, "rarity": 18},
    "Coral Fragment": {"value": 1200, "rarity": 15},
    "Old Compass": {"value": 2000, "rarity": 12},
    "Antique Lure": {"value": 3000, "rarity": 10},
    "Treasure Map": {"value": 5000, "rarity": 8},
    "Bronze Ring": {"value": 8000, "rarity": 6},
    "Silver Coin": {"value": 12000, "rarity": 5},
    "Gold Medallion": {"value": 20000, "rarity": 3},
    "Small Treasure Chest": {"value": 50000, "rarity": 2},
    "Large Treasure Chest": {"value": 100000, "rarity": 1}
}

class FishingGame:
    def __init__(self):
        # Initialize with default starting values
        self.inventory = {}
        self.money = 0  # On-hand money
        self.bank_balance = 0  # Money in bank
        self.current_rod = "Basic Rod"  # Always start with Basic Rod
        self.current_boat = None  # Start with no boat
        self.current_location = "Pond"  # Start at the pond
        self.last_net_use = 0
        self.level = 1
        self.experience = 0
        self.exp_to_next_level = LEVEL_EXP_BASE

        # Time and seasons
        self.current_season = "Spring"
        self.season_days_left = 28
        self.current_time_of_day = "Day"

        # Active events
        self.active_events = {}

        # Boosts
        self.active_boosts = {
            "rarity_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "luck_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "find_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "time_boost": {"active": False, "value": 1.0, "end_time": 0},
            "xp_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "value_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "weather_control": {"active": False, "value": 1.0, "uses_left": 0},
            "midas_touch": {"active": False, "value": 1.0, "uses_left": 0}
        }

        # Owned boosts inventory
        self.boost_inventory = {}

        # Only load saved game data after initialization
        self.load_game()

        # Update time of day based on real time
        self.update_time_of_day()

        # Check for random events
        self.check_for_events()

    def load_game(self):
        try:
            with open('save_data.json', 'r') as f:
                save_data = json.load(f)
                # Load bank_balance (starting at 0 if not present)
                self.bank_balance = save_data.get('bank_balance', 0)
                # Store inventory if it exists
                if 'inventory' in save_data:
                    self.inventory = save_data['inventory']
                # Only load current_rod if player has purchased one
                if 'current_rod' in save_data and save_data['current_rod'] != "Basic Rod":
                    # Verify the rod exists in our fishing_rods dictionary
                    if save_data['current_rod'] in fishing_rods:
                        self.current_rod = save_data['current_rod']
                    else:
                        # Fallback to Basic Rod if saved rod doesn't exist
                        self.current_rod = "Basic Rod"
                # Load Giant Net cooldown
                if 'last_net_use' in save_data:
                    self.last_net_use = save_data['last_net_use']
                # Load experience and level
                if 'level' in save_data:
                    self.level = save_data['level']
                if 'experience' in save_data:
                    self.experience = save_data['experience']
                # Load boat and location
                if 'current_boat' in save_data:
                    self.current_boat = save_data['current_boat']
                if 'current_location' in save_data:
                    self.current_location = save_data['current_location']

                # Load season and time data
                if 'current_season' in save_data:
                    self.current_season = save_data['current_season']
                if 'season_days_left' in save_data:
                    self.season_days_left = save_data['season_days_left']

                # Load active events
                if 'active_events' in save_data:
                    self.active_events = save_data['active_events']

                # Load boosts
                if 'active_boosts' in save_data:
                    self.active_boosts = save_data['active_boosts']
                if 'boost_inventory' in save_data:
                    self.boost_inventory = save_data['boost_inventory']

                # Calculate exp to next level
                self.exp_to_next_level = self.calculate_exp_needed(self.level)

                # Update location access based on boat
                self.update_location_access()
        except FileNotFoundError:
            # If no save file exists, we'll use the default values
            print("Starting a new game...")
            self.reset_game()

    def calculate_exp_needed(self, level):
        """Calculate experience needed for a specific level"""
        return int(LEVEL_EXP_BASE * (LEVEL_EXP_SCALE ** (level - 1)))

    def add_experience(self, exp_amount):
        """Add experience and level up if necessary"""
        # Apply XP boost if active
        if self.active_boosts["xp_boost"]["active"]:
            exp_amount = int(exp_amount * self.active_boosts["xp_boost"]["value"])
            self.active_boosts["xp_boost"]["uses_left"] -= 1
            if self.active_boosts["xp_boost"]["uses_left"] <= 0:
                self.active_boosts["xp_boost"]["active"] = False
                self.active_boosts["xp_boost"]["value"] = 1.0
                print("Your XP Booster has worn off!")

        self.experience += exp_amount
        print(f"+ {exp_amount} EXP")

        while self.experience >= self.exp_to_next_level:
            self.level += 1
            self.experience -= self.exp_to_next_level
            self.exp_to_next_level = self.calculate_exp_needed(self.level)
            print(f"\nðŸŽ‰ LEVEL UP! ðŸŽ‰ You are now level {self.level}!")

            # Level up rewards
            reward = self.level * 1000
            self.bank_balance += reward
            print(f"Level up reward: ${reward:,} added to your bank!")

    def update_location_access(self):
        """Update which locations are accessible based on current boat"""
        # Reset all locations to locked except Pond
        for loc_name in locations:
            if loc_name == "Pond":
                locations[loc_name]["unlocked"] = True
            else:
                locations[loc_name]["unlocked"] = False

        # If player has a boat, unlock appropriate locations
        if self.current_boat:
            for loc_name in boats[self.current_boat]["locations"]:
                locations[loc_name]["unlocked"] = True

    def update_time_of_day(self):
        """Update the time of day based on real system time"""
        current_hour = datetime.now().hour

        for time_name, time_data in time_conditions.items():
            if current_hour in time_data["hours"]:
                self.current_time_of_day = time_name
                break

    def check_for_events(self):
        """Check for random fishing events"""
        # Advance season if needed
        self.season_days_left -= 1
        if self.season_days_left <= 0:
            seasons_list = list(seasons.keys())
            current_index = seasons_list.index(self.current_season)
            next_index = (current_index + 1) % len(seasons_list)
            self.current_season = seasons_list[next_index]
            self.season_days_left = 28
            print(f"\nðŸƒ The season has changed to {self.current_season}! ðŸƒ")
            print(f"{seasons[self.current_season]['description']}")

        # Check for ending events
        expired_events = []
        for event_name, event_data in self.active_events.items():
            event_data["hours_left"] -= 1
            if event_data["hours_left"] <= 0:
                expired_events.append(event_name)

        for event_name in expired_events:
            print(f"\nThe {event_name} event has ended.")
            del self.active_events[event_name]

        # Check for new events
        if len(self.active_events) < 2:  # Limit active events
            for event_name, event_data in events.items():
                if event_name not in self.active_events and random.random() < event_data["chance"]:
                    self.active_events[event_name] = {
                        "rarity_boost": event_data["rarity_boost"],
                        "hours_left": event_data["duration"]
                    }
                    print(f"\nðŸŽ‰ A special event has started: {event_name}! ðŸŽ‰")
                    print(f"{event_data['description']}")
                    print(f"This event will last for {event_data['duration']} hours.")
                    break  # Only start one new event per check

        # Check boost expirations
        current_time = time.time()
        if self.active_boosts["time_boost"]["active"] and current_time > self.active_boosts["time_boost"]["end_time"]:
            self.active_boosts["time_boost"]["active"] = False
            self.active_boosts["time_boost"]["value"] = 1.0
            print("Your Time Warp boost has expired!")

    def reset_game(self):
        """Reset the game to starting conditions"""
        self.inventory = {}
        self.money = 0
        self.bank_balance = 0
        self.current_rod = "Basic Rod"
        self.current_boat = None
        self.current_location = "Pond"
        self.last_net_use = 0
        self.level = 1
        self.experience = 0
        self.exp_to_next_level = LEVEL_EXP_BASE
        self.current_season = "Spring"
        self.season_days_left = 28
        self.active_events = {}
        self.active_boosts = {
            "rarity_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "luck_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "find_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "time_boost": {"active": False, "value": 1.0, "end_time": 0},
            "xp_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "value_boost": {"active": False, "value": 1.0, "uses_left": 0},
            "weather_control": {"active": False, "value": 1.0, "uses_left": 0},
            "midas_touch": {"active": False, "value": 1.0, "uses_left": 0}
        }
        self.boost_inventory = {}
        self.update_location_access()
        self.update_time_of_day()
        # Save the fresh start
        self.save_game()
        print("Game has been reset to starting conditions.")

    def save_game(self):
        with open('save_data.json', 'w') as f:
            json.dump({
                'bank_balance': self.bank_balance,
                'current_rod': self.current_rod,
                'current_boat': self.current_boat,
                'current_location': self.current_location,
                'inventory': self.inventory,
                'last_net_use': self.last_net_use,
                'level': self.level,
                'experience': self.experience,
                'current_season': self.current_season,
                'season_days_left': self.season_days_left,
                'active_events': self.active_events,
                'active_boosts': self.active_boosts,
                'boost_inventory': self.boost_inventory
            }, f)
        print("Game saved successfully!")

    def calculate_rarity_multiplier(self):
        """Calculate the total rarity multiplier from season, time, and events"""
        # Base multiplier
        multiplier = 1.0

        # Season multiplier
        multiplier *= seasons[self.current_season]["rarity_boost"]

        # Time of day multiplier
        multiplier *= time_conditions[self.current_time_of_day]["rarity_boost"]

        # Event multipliers
        for event_data in self.active_events.values():
            multiplier *= event_data["rarity_boost"]

        # Active boost multipliers
        if self.active_boosts["rarity_boost"]["active"]:
            multiplier *= self.active_boosts["rarity_boost"]["value"]

        if self.active_boosts["find_boost"]["active"]:
            multiplier *= self.active_boosts["find_boost"]["value"]

        return multiplier

    def go_fishing(self):
        print(f"\nCasting your line at {self.current_location}...")
        time.sleep(random.uniform(1.0, 2.0))  # Random waiting time to simulate fishing
        print("You feel a tug on your line!")
        time.sleep(0.5)

        # Update boost uses
        boost_messages = []
        if self.active_boosts["rarity_boost"]["active"]:
            self.active_boosts["rarity_boost"]["uses_left"] -= 1
            if self.active_boosts["rarity_boost"]["uses_left"] <= 0:
                self.active_boosts["rarity_boost"]["active"] = False
                self.active_boosts["rarity_boost"]["value"] = 1.0
                boost_messages.append("Your Premium Bait has been used up!")

        if self.active_boosts["find_boost"]["active"]:
            self.active_boosts["find_boost"]["uses_left"] -= 1
            if self.active_boosts["find_boost"]["uses_left"] <= 0:
                self.active_boosts["find_boost"]["active"] = False
                self.active_boosts["find_boost"]["value"] = 1.0
                boost_messages.append("Your Fish Finder has run out of batteries!")

        if self.active_boosts["weather_control"]["active"]:
            self.active_boosts["weather_control"]["uses_left"] -= 1
            if self.active_boosts["weather_control"]["uses_left"] <= 0:
                self.active_boosts["weather_control"]["active"] = False
                self.active_boosts["weather_control"]["value"] = 1.0
                boost_messages.append("Your Weather Control device has stopped working!")

        # Get base rod bonus
        rod_bonus = fishing_rods[self.current_rod]["rare_bonus"]

        # Apply luck boost for multiple catches
        multiple_catch_chance = 0.15  # Base 15% chance
        if self.active_boosts["luck_boost"]["active"]:
            multiple_catch_chance *= self.active_boosts["luck_boost"]["value"]
            self.active_boosts["luck_boost"]["uses_left"] -= 1
            if self.active_boosts["luck_boost"]["uses_left"] <= 0:
                self.active_boosts["luck_boost"]["active"] = False
                self.active_boosts["luck_boost"]["value"] = 1.0
                boost_messages.append("Your Lucky Charm has lost its magic!")

        multiple_catch = random.random() < multiple_catch_chance

        # Get the fish available in the current location
        available_fish = locations[self.current_location]["fish"]

        # Calculate total rarity multiplier
        rarity_multiplier = self.calculate_rarity_multiplier()

        # Apply rod bonus to make better rods catch more rare fish
        fish_probabilities = {}
        total_probability = 0

        for fish_name, fish_data in available_fish.items():
            # Better rods increase chance of rare fish
            # Common fish get less bonus, rare fish get more bonus
            if fish_data["rarity"] <= 3:  # Very rare fish
                adjusted_rate = fish_data["catch_rate"] * (rod_bonus * 1.5 * rarity_multiplier)
            elif fish_data["rarity"] <= 5:  # Rare fish
                adjusted_rate = fish_data["catch_rate"] * (rod_bonus * 1.2 * rarity_multiplier)
            elif fish_data["rarity"] <= 10:  # Medium rarity fish
                adjusted_rate = fish_data["catch_rate"] * (rod_bonus * rarity_multiplier)
            else:  # Common fish
                adjusted_rate = fish_data["catch_rate"] * (rod_bonus * 0.8)

            fish_probabilities[fish_name] = adjusted_rate
            total_probability += adjusted_rate

        # Normalize probabilities
        for fish_name in fish_probabilities:
            fish_probabilities[fish_name] /= total_probability

        # Choose a fish based on calculated probabilities
        fish_items = list(fish_probabilities.items())
        fish_names = [item[0] for item in fish_items]
        fish_probs = [item[1] for item in fish_items]

        caught_fish = random.choices(fish_names, weights=fish_probs, k=1)[0]
        catch_count = random.randint(2, 3) if multiple_catch else 1

        # Add fish to inventory
        self.inventory[caught_fish] = self.inventory.get(caught_fish, 0) + catch_count

        # Calculate experience
        total_exp = available_fish[caught_fish]["exp"] * catch_count

        # Display catch result
        if catch_count > 1:
            print(f"\nAmazing! You caught {catch_count} {caught_fish}!")
        else:
            print(f"\nYou caught a {caught_fish}!")

        # Apply Midas Touch if active
        if self.active_boosts["midas_touch"]["active"]:
            print("âœ¨ Your Midas Touch turns the fish to gold! âœ¨")
            self.active_boosts["midas_touch"]["uses_left"] -= 1
            if self.active_boosts["midas_touch"]["uses_left"] <= 0:
                self.active_boosts["midas_touch"]["active"] = False
                self.active_boosts["midas_touch"]["value"] = 1.0
                boost_messages.append("Your Midas Touch power has faded!")

        # Show boost expiration messages
        for message in boost_messages:
            print(message)

        # Add experience
        self.add_experience(total_exp)

        # Occasionally find miscellaneous items
        if random.random() < 0.1:  # 10% chance
            # Create weighted probabilities based on rarity
            misc_items = list(miscellaneous_items.items())
            item_names = [item[0] for item in misc_items]
            item_weights = [1.0/item[1]["rarity"] for item in misc_items]

            # Normalize weights
            total_weight = sum(item_weights)
            item_weights = [w/total_weight for w in item_weights]

            found_item = random.choices(item_names, weights=item_weights, k=1)[0]
            self.inventory[found_item] = self.inventory.get(found_item, 0) + 1
            print(f"\nYou also found a {found_item}!")

        return

    def use_giant_net(self):
        current_time = time.time()
        cooldown = GIANT_NET_COOLDOWN

        # Apply time boost if active
        if self.active_boosts["time_boost"]["active"]:
            cooldown *= self.active_boosts["time_boost"]["value"]

        if current_time - self.last_net_use < cooldown:
            remaining = int(cooldown - (current_time - self.last_net_use))
            print(f"\nGiant net is cooling down! Wait {remaining} seconds.")
            return

        print("\nCasting giant net...")
        time.sleep(1.5)

        # Get fish available in current location
        available_fish = locations[self.current_location]["fish"]

        # Separate location fish into rarity tiers
        local_common = [name for name in available_fish if available_fish[name]["rarity"] > 10]
        local_uncommon = [name for name in available_fish if 5 < available_fish[name]["rarity"] <= 10]
        local_rare = [name for name in available_fish if 2 < available_fish[name]["rarity"] <= 5]
        local_very_rare = [name for name in available_fish if available_fish[name]["rarity"] <= 2]

        # Fallback to global lists if local lists are empty
        if not local_common:
            local_common = common_fish
        if not local_uncommon:
            local_uncommon = uncommon_fish
        if not local_rare:
            local_rare = rare_fish
        if not local_very_rare:
            local_very_rare = very_rare_fish

        # Calculate rarity multiplier based on season, time, events, and boosts
        rarity_multiplier = self.calculate_rarity_multiplier()

        # Giant Net now catches fish based on rarity tiers with influence from rarity multiplier
        catches = random.randint(4, 8)  # Slightly more catches
        caught_fish = []

        # Adjust distribution based on rarity multiplier
        common_chance = max(40, 60 - rarity_multiplier * 10)  # Decreases with higher rarity multiplier
        uncommon_chance = min(40, 30 + rarity_multiplier * 5)  # Increases with higher rarity multiplier
        rare_chance = min(25, 8 + rarity_multiplier * 5)  # Increases with higher rarity multiplier
        very_rare_chance = min(15, 2 + rarity_multiplier * 3)  # Increases with higher rarity multiplier

        # Distribution adjusted by rarity multiplier
        for _ in range(catches):
            rarity_roll = random.random() * 100
            if rarity_roll <= common_chance and local_common:
                caught_fish.append(random.choice(local_common))
            elif rarity_roll <= (common_chance + uncommon_chance) and local_uncommon:
                caught_fish.append(random.choice(local_uncommon))
            elif rarity_roll <= (common_chance + uncommon_chance + rare_chance) and local_rare:
                caught_fish.append(random.choice(local_rare))
            elif local_very_rare:
                caught_fish.append(random.choice(local_very_rare))
            else:
                caught_fish.append(random.choice(local_common or common_fish))

        total_exp = 0
        for fish_name in caught_fish:
            self.inventory[fish_name] = self.inventory.get(fish_name, 0) + 1
            print(f"Caught a {fish_name}!")
            # Add experience for each fish
            fish_exp = fish_types[fish_name]["exp"]
            total_exp += fish_exp

        # Add the total experience
        self.add_experience(total_exp)

        # Randomly find miscellaneous items
        misc_count = random.randint(0, 2)  # 0-2 misc items
        if misc_count > 0:
            print("\nYour net also caught:")
            for _ in range(misc_count):
                # Weighted random choice
                misc_items = list(miscellaneous_items.items())
                item_names = [item[0] for item in misc_items]
                item_weights = [1.0/item[1]["rarity"] for item in misc_items]

                # Normalize weights
                total_weight = sum(item_weights)
                item_weights = [w/total_weight for w in item_weights]

                found_item = random.choices(item_names, weights=item_weights, k=1)[0]
                self.inventory[found_item] = self.inventory.get(found_item, 0) + 1
                print(f"- A {found_item}")

        self.last_net_use = current_time
        # Save after using giant net to store cooldown time
        self.save_game()

    def sell_items(self, item_type="fish"):
        if item_type == "fish":
            items = {k: v for k, v in self.inventory.items() if k in fish_types}
        else:
            items = {k: v for k, v in self.inventory.items() if k in miscellaneous_items}

        if not items:
            print(f"No {item_type} to sell!")
            return

        print(f"\nYour {item_type}:")
        for i, (item_name, quantity) in enumerate(items.items(), 1):
            if item_type == "fish":
                value = fish_types[item_name]["price"]
                if self.active_boosts["value_boost"]["active"]:
                    value = int(value * self.active_boosts["value_boost"]["value"])
            else:
                value = miscellaneous_items[item_name]["value"]

            print(f"{i}. {item_name} (x{quantity}) - ${value:,} each")

        sell_all = input("\nSell all items? (y/n): ").lower() == 'y'

        if sell_all:
            total_value = 0
            for item_name, quantity in items.items():
                if item_type == "fish":
                    value = fish_types[item_name]["price"]
                    if self.active_boosts["value_boost"]["active"]:
                        value = int(value * self.active_boosts["value_boost"]["value"])
                else:
                    value = miscellaneous_items[item_name]["value"]

                total_value += value * quantity
                self.inventory[item_name] = 0

            # Remove empty inventory entries
            self.inventory = {k: v for k, v in self.inventory.items() if v > 0}

            # Apply value boost usage if active
            if self.active_boosts["value_boost"]["active"] and item_type == "fish":
                self.active_boosts["value_boost"]["uses_left"] -= 1
                if self.active_boosts["value_boost"]["uses_left"] <= 0:
                    self.active_boosts["value_boost"]["active"] = False
                    self.active_boosts["value_boost"]["value"] = 1.0
                    print("Your Golden Hook has lost its luster!")

            self.bank_balance += total_value
            print(f"\nSold all {item_type} for ${total_value:,}!")
            print(f"New bank balance: ${self.bank_balance:,}")

            # Save after selling
            self.save_game()
            return

        try:
            choice = int(input("\nEnter number to sell (0 to cancel): ")) - 1
            if choice == -1:
                return

            item_name = list(items.keys())[choice]
            quantity = int(input(f"How many {item_name} to sell? (max {items[item_name]}): "))

            if quantity <= 0:
                print("Invalid quantity!")
                return

            if quantity > self.inventory[item_name]:
                print("You don't have that many!")
                return

            if item_type == "fish":
                value = fish_types[item_name]["price"]
                if self.active_boosts["value_boost"]["active"]:
                    value = int(value * self.active_boosts["value_boost"]["value"])
                    # Count this as one use
                    self.active_boosts["value_boost"]["uses_left"] -= 1
                    if self.active_boosts["value_boost"]["uses_left"] <= 0:
                        self.active_boosts["value_boost"]["active"] = False
                        self.active_boosts["value_boost"]["value"] = 1.0
                        print("Your Golden Hook has lost its luster!")
            else:
                value = miscellaneous_items[item_name]["value"]

            total_value = value * quantity
            self.bank_balance += total_value
            self.inventory[item_name] -= quantity
            if self.inventory[item_name] == 0:
                del self.inventory[item_name]
            print(f"\nSold {quantity} {item_name} for ${total_value:,}!")
            print(f"New bank balance: ${self.bank_balance:,}")

            # Save after selling to ensure bank balance is updated
            self.save_game()

        except (ValueError, IndexError):
            print("Invalid input!")

    def buy_rod(self):
        print("\nAvailable Fishing Rods:")
        available_rods = []
        for rod_name, data in fishing_rods.items():
            if rod_name != self.current_rod:
                available_rods.append(rod_name)
                print(f"{len(available_rods)}. {rod_name}: ${data['price']:,} (Bonus: x{data['rare_bonus']})")

        if not available_rods:
            print("You already own the best rod!")
            input("\nPress Enter to continue...")
            return

        try:
            choice = input("\nEnter number to purchase (0 to cancel): ")
            if choice == "0" or not choice:
                return

            rod_index = int(choice) - 1
            if 0 <= rod_index < len(available_rods):
                rod_name = available_rods[rod_index]

                price = fishing_rods[rod_name]["price"]
                if self.bank_balance >= price:
                    self.bank_balance -= price
                    self.current_rod = rod_name
                    print(f"\nPurchased {rod_name}!")
                    print(f"New bank balance: ${self.bank_balance:,}")

                    # Save after purchasing to ensure rod and bank balance are updated
                    self.save_game()
                else:
                    print("\nNot enough money!")
            else:
                print("Invalid selection!")
        except ValueError:
            print("Please enter a valid number!")

    def buy_boat(self):
        print("\nAvailable Boats:")
        available_boats = []
        for boat_name, data in boats.items():
            if boat_name != self.current_boat:
                available_boats.append(boat_name)
                print(f"{len(available_boats)}. {boat_name}: ${data['price']:,}")
                print(f"   Unlocks: {', '.join(data['locations'])}")

        if not available_boats:
            print("You already own the best boat!")
            input("\nPress Enter to continue...")
            return

        try:
            choice = input("\nEnter number to purchase (0 to cancel): ")
            if choice == "0" or not choice:
                return

            boat_index = int(choice) - 1
            if 0 <= boat_index < len(available_boats):
                boat_name = available_boats[boat_index]

                price = boats[boat_name]["price"]
                if self.bank_balance >= price:
                    self.bank_balance -= price
                    self.current_boat = boat_name
                    print(f"\nPurchased {boat_name}!")
                    print(f"New bank balance: ${self.bank_balance:,}")

                    # Update accessible locations
                    self.update_location_access()

                    # Save after purchasing
                    self.save_game()
                else:
                    print("\nNot enough money!")
            else:
                print("Invalid selection!")
        except ValueError:
            print("Please enter a valid number!")

    def buy_boost(self):
        print("\nAvailable Fishing Boosts:")
        boost_list = []
        for boost_name, data in fishing_boosts.items():
            boost_list.append(boost_name)
            duration_text = f"{data['duration']} catches" if data['effect'] != 'time_boost' else f"{data['duration']} minutes"
            print(f"{len(boost_list)}. {boost_name}: ${data['price']:,}")
            print(f"   Effect: {data['description']}")

        try:
            choice = input("\nEnter number to purchase (0 to cancel): ")
            if choice == "0" or not choice:
                return

            boost_index = int(choice) - 1
            if 0 <= boost_index < len(boost_list):
                boost_name = boost_list[boost_index]

                # Ask if they want to buy multiple
                buy_multiple = input("\nBuy multiple? (y/n): ").lower() == 'y'

                if buy_multiple:
                    max_affordable = self.bank_balance // fishing_boosts[boost_name]["price"]
                    if max_affordable <= 0:
                        print("\nNot enough money for even one boost!")
                        return

                    print(f"\nYou can afford up to {max_affordable} of this boost.")
                    try:
                        quantity = int(input(f"How many would you like to buy? (1-{max_affordable}): "))
                        if quantity <= 0 or quantity > max_affordable:
                            print("Invalid quantity!")
                            return

                        total_price = fishing_boosts[boost_name]["price"] * quantity
                        self.bank_balance -= total_price
                        self.boost_inventory[boost_name] = self.boost_inventory.get(boost_name, 0) + quantity
                        print(f"\nPurchased {quantity} {boost_name} for ${total_price:,}!")
                        print(f"New bank balance: ${self.bank_balance:,}")

                        # Save after purchasing
                        self.save_game()
                    except ValueError:
                        print("Please enter a valid number!")
                else:
                    # Regular single purchase
                    price = fishing_boosts[boost_name]["price"]
                    if self.bank_balance >= price:
                        self.bank_balance -= price
                        self.boost_inventory[boost_name] = self.boost_inventory.get(boost_name, 0) + 1
                        print(f"\nPurchased {boost_name}!")
                        print(f"New bank balance: ${self.bank_balance:,}")

                        # Save after purchasing
                        self.save_game()
                    else:
                        print("\nNot enough money!")
            else:
                print("Invalid selection!")
        except ValueError:
            print("Please enter a valid number!")

    def use_boost(self):
        if not self.boost_inventory:
            print("\nYou don't have any boosts!")
            return

        print("\nYour Boosts:")
        boost_list = []
        for boost_name, quantity in self.boost_inventory.items():
            print(f"{len(boost_list) + 1}. {boost_name} (x{quantity})")
            print(f"   {fishing_boosts[boost_name]['description']}")
            boost_list.append(boost_name)

        try:
            choice = int(input("\nEnter number to use (0 to cancel): ")) - 1
            if choice == -1:
                return

            boost_name = boost_list[choice]

            # Check if user wants to apply multiple boosts at once
            max_quantity = self.boost_inventory[boost_name]

            if max_quantity > 1:
                use_multiple = input(f"\nYou have {max_quantity} {boost_name}s. Use multiple at once? (y/n): ").lower() == 'y'

                if use_multiple:
                    try:
                        quantity = int(input(f"How many would you like to use? (1-{max_quantity}): "))
                        if quantity <= 0 or quantity > max_quantity:
                            print("Invalid quantity!")
                            return
                    except ValueError:
                        print("Please enter a valid number!")
                        return
                else:
                    quantity = 1
            else:
                quantity = 1

            # Apply the boost
            boost_data = fishing_boosts[boost_name]
            effect = boost_data["effect"]
            value = boost_data["value"]
            duration = boost_data["duration"]

            if effect == "time_boost":
                # Time boost uses real time - stack duration
                self.active_boosts[effect]["active"] = True
                self.active_boosts[effect]["value"] = value
                # Extend duration by (duration * quantity) minutes
                if self.active_boosts[effect]["end_time"] > time.time():
                    # Add to existing time if already active
                    self.active_boosts[effect]["end_time"] += (duration * quantity * 60)
                else:
                    # Set new end time if not active
                    self.active_boosts[effect]["end_time"] = time.time() + (duration * quantity * 60)

                # Calculate total minutes for display
                total_minutes = duration * quantity
                hours, minutes = divmod(total_minutes, 60)
                time_text = f"{hours}h {minutes}m" if hours > 0 else f"{minutes}m"
                print(f"\nActivated {quantity} {boost_name}(s) for a total of {time_text}!")
            else:
                # Other boosts use count-based duration
                self.active_boosts[effect]["active"] = True
                self.active_boosts[effect]["value"] = value

                # Add to existing uses if already active
                if self.active_boosts[effect]["active"]:
                    self.active_boosts[effect]["uses_left"] += (duration * quantity)
                else:
                    self.active_boosts[effect]["uses_left"] = duration * quantity

                print(f"\nActivated {quantity} {boost_name}(s) for a total of {duration * quantity} uses!")

            # Remove from inventory
            self.boost_inventory[boost_name] -= quantity
            if self.boost_inventory[boost_name] <= 0:
                del self.boost_inventory[boost_name]

            print(f"{boost_data['description']}")

            # Save after using boost
            self.save_game()

        except (ValueError, IndexError):
            print("Invalid input!")

    def change_location(self):
        print("\nAvailable Fishing Locations:")
        location_list = []
        for loc_name, loc_data in locations.items():
            location_list.append(loc_name)
            status = "ðŸ”“ UNLOCKED" if loc_data["unlocked"] else "ðŸ”’ LOCKED"
            current = " (Current)" if loc_name == self.current_location else ""
            print(f"{len(location_list)}. {loc_name}: {status}{current}")
            print(f"   {loc_data['description']}")

        try:
            choice = input("\nEnter number to travel to (0 to cancel): ")
            if choice == "0" or not choice:
                return

            loc_index = int(choice) - 1
            if 0 <= loc_index < len(location_list):
                location_name = location_list[loc_index]

                if not locations[location_name]["unlocked"]:
                    required_boat = None
                    for boat_name, boat_data in boats.items():
                        if location_name in boat_data["locations"]:
                            required_boat = boat_name
                            break
                    print(f"\nThis location is locked! You need at least a {required_boat} to access it.")
                    return

                self.current_location = location_name
                print(f"\nTraveled to {location_name}!")

                # Save after changing location
                self.save_game()
            else:
                print("Invalid selection!")
        except ValueError:
            print("Please enter a valid number!")

    def display_stats(self):
        fish_value = sum(fish_types[item]["price"] * qty 
                        for item, qty in self.inventory.items() 
                        if item in fish_types)
        misc_value = sum(miscellaneous_items[item]["value"] * qty 
                        for item, qty in self.inventory.items() 
                        if item in miscellaneous_items)

        # Get time condition description
        time_desc = time_conditions[self.current_time_of_day]["description"]

        # Get season description
        season_desc = seasons[self.current_season]["description"]

        # Format active boosts
        active_boost_text = []
        for boost_type, boost_data in self.active_boosts.items():
            if boost_data["active"]:
                if boost_type == "time_boost":
                    time_left = int(boost_data["end_time"] - time.time())
                    if time_left > 0:
                        mins, secs = divmod(time_left, 60)
                        active_boost_text.append(f"{boost_type.replace('_', ' ').title()}: {mins}m {secs}s left")
                else:
                    active_boost_text.append(f"{boost_type.replace('_', ' ').title()}: {boost_data['uses_left']} uses left")

        print(f"\nLevel: {self.level}   XP: {self.experience}/{self.exp_to_next_level}")
        print(f"Bank Balance: ${self.bank_balance:,}")
        print(f"Current Rod: {self.current_rod}")
        print(f"Current Boat: {self.current_boat or 'None'}")
        print(f"Current Location: {self.current_location}")
        print(f"Season: {self.current_season} ({self.season_days_left} days left) - {season_desc}")
        print(f"Time: {self.current_time_of_day} - {time_desc}")

        # Show active events
        if self.active_events:
            print("\nActive Events:")
            for event_name, event_data in self.active_events.items():
                print(f"- {event_name} ({event_data['hours_left']} hours left)")

        # Show active boosts
        if active_boost_text:
            print("\nActive Boosts:")
            for boost in active_boost_text:
                print(f"- {boost}")

        print(f"\nInventory Value: ${(fish_value + misc_value):,}")
        print(f"Total Net Worth: ${(self.bank_balance + fish_value + misc_value):,}")

def main():
    game = FishingGame()

    while True:
        clear()
        game.display_stats()
        print("\nOptions:")
        print("1. Go Fishing")
        print("2. Use Giant Net")
        print("3. Sell Fish")
        print("4. Sell Items")
        print("5. Buy Rod")
        print("6. Buy Boat")
        print("7. Buy Boosts")
        print("8. Use Boost")
        print("9. Change Location")
        print("V. View Inventory")
        print("S. Save Game")
        print("0. Exit Game")
        print("R. Reset Game (WARNING: Starts over!)")

        choice = input("\nChoose an option: ").lower()

        if choice == "1":
            game.go_fishing()
        elif choice == "2":
            game.use_giant_net()
        elif choice == "3":
            game.sell_items("fish")
        elif choice == "4":
            game.sell_items("misc")
        elif choice == "5":
            game.buy_rod()
        elif choice == "6":
            game.buy_boat()
        elif choice == "7":
            game.buy_boost()
        elif choice == "8":
            game.use_boost()
        elif choice == "9":
            game.change_location()
        elif choice == "v":
            clear()
            if game.inventory:
                print("\nYour Inventory:")
                for item, qty in game.inventory.items():
                    if item in fish_types:
                        print(f"{item}: {qty} (Value: ${fish_types[item]['price']:,} each)")
                    elif item in miscellaneous_items:
                        print(f"{item}: {qty} (Value: ${miscellaneous_items[item]['value']:,} each)")
            else:
                print("\nInventory is empty!")

            print("\nYour Boosts:")
            if game.boost_inventory:
                for boost_name, quantity in game.boost_inventory.items():
                    print(f"{boost_name}: {quantity}")
                    print(f"  {fishing_boosts[boost_name]['description']}")
            else:
                print("No boosts in inventory")
        elif choice == "s":
            game.save_game()
        elif choice == "0":
            game.save_game()
            print("\nGame saved! Goodbye!")
            break
        elif choice == "r":
            confirm = input("\nWARNING: This will reset all progress! Type 'RESET' to confirm: ")
            if confirm == "RESET":
                game.reset_game()
                print("Game has been reset. Starting fresh!")
            else:
                print("Reset cancelled.")
        else:
            print("\nInvalid choice!")

        input("\nPress Enter to continue...")

if __name__ == "__main__":
    main()
